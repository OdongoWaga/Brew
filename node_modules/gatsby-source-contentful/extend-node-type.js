"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const Promise = require(`bluebird`);

const _require = require(`gatsby/graphql`),
      GraphQLObjectType = _require.GraphQLObjectType,
      GraphQLBoolean = _require.GraphQLBoolean,
      GraphQLString = _require.GraphQLString,
      GraphQLInt = _require.GraphQLInt,
      GraphQLFloat = _require.GraphQLFloat,
      GraphQLJSON = _require.GraphQLJSON;

const qs = require(`qs`);

const base64Img = require(`base64-img`);

const _ = require(`lodash`);

const path = require(`path`);

const cacheImage = require(`./cache-image`);

const _require2 = require(`./schemes`),
      ImageFormatType = _require2.ImageFormatType,
      ImageResizingBehavior = _require2.ImageResizingBehavior,
      ImageCropFocusType = _require2.ImageCropFocusType;

const isImage = image => _.includes([`image/jpeg`, `image/jpg`, `image/png`, `image/webp`, `image/gif`], _.get(image, `file.contentType`));

const getBase64Image = imageProps => {
  if (!imageProps) return null;
  const requestUrl = `https:${imageProps.baseUrl}?w=20`; // TODO add caching.

  return new Promise(resolve => {
    base64Img.requestBase64(requestUrl, (a, b, body) => {
      resolve(body);
    });
  });
};

const getBasicImageProps = (image, args) => {
  let aspectRatio;

  if (args.width && args.height) {
    aspectRatio = args.width / args.height;
  } else {
    aspectRatio = image.file.details.image.width / image.file.details.image.height;
  }

  return {
    baseUrl: image.file.url,
    contentType: image.file.contentType,
    aspectRatio,
    width: image.file.details.image.width,
    height: image.file.details.image.height
  };
};

const createUrl = (imgUrl, options = {}) => {
  // Convert to Contentful names and filter out undefined/null values.
  const args = _.pickBy({
    w: options.width,
    h: options.height,
    fl: options.jpegProgressive ? `progressive` : null,
    q: options.quality,
    fm: options.toFormat || ``,
    fit: options.resizingBehavior || ``,
    f: options.cropFocus || ``,
    bg: options.background || ``
  }, _.identity);

  return `${imgUrl}?${qs.stringify(args)}`;
};

exports.createUrl = createUrl;

const resolveFixed = (image, options) => {
  if (!isImage(image)) return null;

  const _getBasicImageProps = getBasicImageProps(image, options),
        baseUrl = _getBasicImageProps.baseUrl,
        width = _getBasicImageProps.width,
        aspectRatio = _getBasicImageProps.aspectRatio;

  let desiredAspectRatio = aspectRatio; // If we're cropping, calculate the specified aspect ratio.

  if (options.height) {
    desiredAspectRatio = options.width / options.height;
  } // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  } // Create sizes (in width) for the image. If the width of the
  // image is 800px, the sizes would then be: 800, 1200, 1600,
  // 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution


  let fixedSizes = [];
  fixedSizes.push(options.width);
  fixedSizes.push(options.width * 1.5);
  fixedSizes.push(options.width * 2);
  fixedSizes.push(options.width * 3);
  fixedSizes = fixedSizes.map(Math.round); // Filter out sizes larger than the image's width.

  const filteredSizes = fixedSizes.filter(size => size <= width); // Sort sizes for prettiness.

  const sortedSizes = _.sortBy(filteredSizes); // Create the srcSet.


  const srcSet = sortedSizes.map((size, i) => {
    let resolution;

    switch (i) {
      case 0:
        resolution = `1x`;
        break;

      case 1:
        resolution = `1.5x`;
        break;

      case 2:
        resolution = `2x`;
        break;

      case 3:
        resolution = `3x`;
        break;

      default:
    }

    const h = Math.round(size / desiredAspectRatio);
    return `${createUrl(baseUrl, Object.assign({}, options, {
      width: size,
      height: h
    }))} ${resolution}`;
  }).join(`,\n`);
  let pickedHeight;

  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = options.width / desiredAspectRatio;
  }

  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    width: Math.round(options.width),
    height: Math.round(pickedHeight),
    src: createUrl(baseUrl, Object.assign({}, options, {
      width: options.width
    })),
    srcSet
  };
};

exports.resolveFixed = resolveFixed;

const resolveFluid = (image, options) => {
  if (!isImage(image)) return null;

  const _getBasicImageProps2 = getBasicImageProps(image, options),
        baseUrl = _getBasicImageProps2.baseUrl,
        width = _getBasicImageProps2.width,
        aspectRatio = _getBasicImageProps2.aspectRatio;

  let desiredAspectRatio = aspectRatio; // If we're cropping, calculate the specified aspect ratio.

  if (options.maxHeight) {
    desiredAspectRatio = options.maxWidth / options.maxHeight;
  } // If the users didn't set a default sizes, we'll make one.


  if (!options.sizes) {
    options.sizes = `(max-width: ${options.maxWidth}px) 100vw, ${options.maxWidth}px`;
  } // Create sizes (in width) for the image. If the max width of the container
  // for the rendered markdown file is 800px, the sizes would then be: 200,
  // 400, 800, 1200, 1600, 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution


  let fluidSizes = [];
  fluidSizes.push(options.maxWidth / 4);
  fluidSizes.push(options.maxWidth / 2);
  fluidSizes.push(options.maxWidth);
  fluidSizes.push(options.maxWidth * 1.5);
  fluidSizes.push(options.maxWidth * 2);
  fluidSizes.push(options.maxWidth * 3);
  fluidSizes = fluidSizes.map(Math.round); // Filter out sizes larger than the image's maxWidth.

  const filteredSizes = fluidSizes.filter(size => size <= width); // Add the original image (if it isn't already in there) to ensure the largest image possible
  // is available for small images.

  if (!filteredSizes.includes(parseInt(width))) filteredSizes.push(width); // Sort sizes for prettiness.

  const sortedSizes = _.sortBy(filteredSizes); // Create the srcSet.


  const srcSet = sortedSizes.map(width => {
    const h = Math.round(width / desiredAspectRatio);
    return `${createUrl(image.file.url, Object.assign({}, options, {
      width,
      height: h
    }))} ${Math.round(width)}w`;
  }).join(`,\n`);
  return {
    aspectRatio: desiredAspectRatio,
    baseUrl,
    src: createUrl(baseUrl, Object.assign({}, options, {
      width: options.maxWidth,
      height: options.maxHeight
    })),
    srcSet,
    sizes: options.sizes
  };
};

exports.resolveFluid = resolveFluid;

const resolveResize = (image, options) => {
  if (!isImage(image)) return null;

  const _getBasicImageProps3 = getBasicImageProps(image, options),
        baseUrl = _getBasicImageProps3.baseUrl,
        aspectRatio = _getBasicImageProps3.aspectRatio; // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  const pickedWidth = options.width;
  let pickedHeight;

  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = pickedWidth / aspectRatio;
  }

  return {
    src: createUrl(image.file.url, options),
    width: Math.round(pickedWidth),
    height: Math.round(pickedHeight),
    aspectRatio,
    baseUrl
  };
};

exports.resolveResize = resolveResize;

const fixedNodeType = ({
  name,
  getTracedSVG
}) => {
  return {
    type: new GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: GraphQLString,

          resolve(imageProps) {
            return getBase64Image(imageProps);
          }

        },
        tracedSVG: {
          type: GraphQLString,
          resolve: getTracedSVG
        },
        aspectRatio: {
          type: GraphQLFloat
        },
        width: {
          type: GraphQLFloat
        },
        height: {
          type: GraphQLFloat
        },
        src: {
          type: GraphQLString
        },
        srcSet: {
          type: GraphQLString
        },
        srcWebp: {
          type: GraphQLString,

          resolve({
            image,
            options,
            context
          }) {
            if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fixed = resolveFixed(image, Object.assign({}, options, {
              toFormat: `webp`
            }));
            return _.get(fixed, `src`);
          }

        },
        srcSetWebp: {
          type: GraphQLString,

          resolve({
            image,
            options,
            context
          }) {
            if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fixed = resolveFixed(image, Object.assign({}, options, {
              toFormat: `webp`
            }));
            return _.get(fixed, `srcSet`);
          }

        }
      }
    }),
    args: {
      width: {
        type: GraphQLInt,
        defaultValue: 400
      },
      height: {
        type: GraphQLInt
      },
      quality: {
        type: GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: ImageFormatType,
        defaultValue: ``
      },
      resizingBehavior: {
        type: ImageResizingBehavior
      },
      cropFocus: {
        type: ImageCropFocusType,
        defaultValue: null
      },
      background: {
        type: GraphQLString,
        defaultValue: null
      }
    },
    resolve: (image, options, context) => Promise.resolve(resolveFixed(image, options)).then(node => {
      return Object.assign({}, node, {
        image,
        options,
        context
      });
    })
  };
};

const fluidNodeType = ({
  name,
  getTracedSVG
}) => {
  return {
    type: new GraphQLObjectType({
      name: name,
      fields: {
        base64: {
          type: GraphQLString,

          resolve(imageProps) {
            return getBase64Image(imageProps);
          }

        },
        tracedSVG: {
          type: GraphQLString,
          resolve: getTracedSVG
        },
        aspectRatio: {
          type: GraphQLFloat
        },
        src: {
          type: GraphQLString
        },
        srcSet: {
          type: GraphQLString
        },
        srcWebp: {
          type: GraphQLString,

          resolve({
            image,
            options,
            context
          }) {
            if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fluid = resolveFluid(image, Object.assign({}, options, {
              toFormat: `webp`
            }));
            return _.get(fluid, `src`);
          }

        },
        srcSetWebp: {
          type: GraphQLString,

          resolve({
            image,
            options,
            context
          }) {
            if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
              return null;
            }

            const fluid = resolveFluid(image, Object.assign({}, options, {
              toFormat: `webp`
            }));
            return _.get(fluid, `srcSet`);
          }

        },
        sizes: {
          type: GraphQLString
        }
      }
    }),
    args: {
      maxWidth: {
        type: GraphQLInt,
        defaultValue: 800
      },
      maxHeight: {
        type: GraphQLInt
      },
      quality: {
        type: GraphQLInt,
        defaultValue: 50
      },
      toFormat: {
        type: ImageFormatType,
        defaultValue: ``
      },
      resizingBehavior: {
        type: ImageResizingBehavior
      },
      cropFocus: {
        type: ImageCropFocusType,
        defaultValue: null
      },
      background: {
        type: GraphQLString,
        defaultValue: null
      },
      sizes: {
        type: GraphQLString
      }
    },
    resolve: (image, options, context) => Promise.resolve(resolveFluid(image, options)).then(node => {
      return Object.assign({}, node, {
        image,
        options,
        context
      });
    })
  };
};

exports.extendNodeType = ({
  type,
  store
}) => {
  if (type.name.match(/contentful.*RichTextNode/)) {
    return {
      nodeType: {
        type: GraphQLString,
        deprecationReason: `This field is deprecated, please use 'json' instead.`
      },
      json: {
        type: GraphQLJSON,
        resolve: (source, fieldArgs) => {
          const contentJSON = JSON.parse(source.internal.content);
          return contentJSON;
        }
      }
    };
  }

  if (type.name !== `ContentfulAsset`) {
    return {};
  }

  const getTracedSVG =
  /*#__PURE__*/
  function () {
    var _ref = (0, _asyncToGenerator2.default)(function* (args) {
      const _require3 = require(`gatsby-plugin-sharp`),
            traceSVG = _require3.traceSVG;

      const image = args.image,
            options = args.options;
      const contentType = image.file.contentType;

      if (contentType.indexOf(`image/`) !== 0) {
        return null;
      }

      const absolutePath = yield cacheImage(store, image, options);
      const extension = path.extname(absolutePath);
      return traceSVG({
        file: {
          internal: image.internal,
          name: image.file.fileName,
          extension,
          absolutePath
        },
        args: {
          toFormat: ``
        },
        fileArgs: options
      });
    });

    return function getTracedSVG(_x) {
      return _ref.apply(this, arguments);
    };
  }(); // TODO: Remove resolutionsNode and sizesNode for Gatsby v3


  const fixedNode = fixedNodeType({
    name: `ContentfulFixed`,
    getTracedSVG
  });
  const resolutionsNode = fixedNodeType({
    name: `ContentfulResolutions`,
    getTracedSVG
  });
  resolutionsNode.deprecationReason = `Resolutions was deprecated in Gatsby v2. It's been renamed to "fixed" https://example.com/write-docs-and-fix-this-example-link`;
  const fluidNode = fluidNodeType({
    name: `ContentfulFluid`,
    getTracedSVG
  });
  const sizesNode = fluidNodeType({
    name: `ContentfulSizes`,
    getTracedSVG
  });
  sizesNode.deprecationReason = `Sizes was deprecated in Gatsby v2. It's been renamed to "fluid" https://example.com/write-docs-and-fix-this-example-link`;
  return {
    fixed: fixedNode,
    resolutions: resolutionsNode,
    fluid: fluidNode,
    sizes: sizesNode,
    resize: {
      type: new GraphQLObjectType({
        name: `ContentfulResize`,
        fields: {
          base64: {
            type: GraphQLString,

            resolve(imageProps) {
              return getBase64Image(imageProps);
            }

          },
          tracedSVG: {
            type: GraphQLString,
            resolve: getTracedSVG
          },
          src: {
            type: GraphQLString
          },
          width: {
            type: GraphQLInt
          },
          height: {
            type: GraphQLInt
          },
          aspectRatio: {
            type: GraphQLFloat
          }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        jpegProgressive: {
          type: GraphQLBoolean,
          defaultValue: true
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        background: {
          type: GraphQLString,
          defaultValue: null
        }
      },

      resolve(image, options, context) {
        return resolveResize(image, options);
      }

    }
  };
};