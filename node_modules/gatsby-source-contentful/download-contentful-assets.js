"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

const ProgressBar = require(`progress`);

const _require = require(`gatsby-source-filesystem`),
      createRemoteFileNode = _require.createRemoteFileNode;

const bar = new ProgressBar(`Downloading Contentful Assets [:bar] :current/:total :elapsed secs :percent`, {
  total: 0,
  width: 30
});
let totalJobs = 0;
/**
 * @name downloadContentfulAssets
 * @description Downloads Contentful assets to the local filesystem.
 * The asset files will be downloaded and cached. Use `localFile` to link to them
 * @param gatsbyFunctions - Gatsby's internal helper functions
 */

const downloadContentfulAssets =
/*#__PURE__*/
function () {
  var _ref = (0, _asyncToGenerator2.default)(function* (gatsbyFunctions) {
    const _gatsbyFunctions$acti = gatsbyFunctions.actions,
          createNode = _gatsbyFunctions$acti.createNode,
          touchNode = _gatsbyFunctions$acti.touchNode,
          createNodeId = gatsbyFunctions.createNodeId,
          store = gatsbyFunctions.store,
          cache = gatsbyFunctions.cache,
          getNodes = gatsbyFunctions.getNodes; // Any ContentfulAsset nodes will be downloaded, cached and copied to public/static
    // regardless of if you use `localFile` to link an asset or not.

    const contentfulAssetNodes = getNodes().filter(n => n.internal.owner === `gatsby-source-contentful` && n.internal.type === `ContentfulAsset`);
    yield Promise.all(contentfulAssetNodes.map(
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _asyncToGenerator2.default)(function* (node) {
        totalJobs += 1;
        bar.total = totalJobs;
        let fileNodeID;
        const remoteDataCacheKey = `contentful-asset-${node.contentful_id}`;
        const cacheRemoteData = yield cache.get(remoteDataCacheKey);
        const url = `http://${node.file.url.slice(2)}`; // Avoid downloading the asset again if it's been cached
        // Note: Contentful Assets do not provide useful metadata
        // to compare a modified asset to a cached version?

        if (cacheRemoteData) {
          fileNodeID = cacheRemoteData.fileNodeID; // eslint-disable-line prefer-destructuring

          touchNode({
            nodeId: cacheRemoteData.fileNodeID
          });
        } // If we don't have cached data, download the file


        if (!fileNodeID) {
          try {
            const fileNode = yield createRemoteFileNode({
              url,
              store,
              cache,
              createNode,
              createNodeId
            });

            if (fileNode) {
              bar.tick();
              fileNodeID = fileNode.id;
              yield cache.set(remoteDataCacheKey, {
                fileNodeID
              });
            }
          } catch (err) {// Ignore
          }
        }

        if (fileNodeID) {
          node.localFile___NODE = fileNodeID;
        }

        return node;
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }()));
  });

  return function downloadContentfulAssets(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.downloadContentfulAssets = downloadContentfulAssets;