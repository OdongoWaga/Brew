"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _BackgroundUtils = _interopRequireDefault(require("./BackgroundUtils"));

var _HelperUtils = require("./HelperUtils");

var _ImageUtils = require("./ImageUtils");

var _StyleUtils = require("./StyleUtils");

var _IntersectionObserverUtils = require("./IntersectionObserverUtils");

class BackgroundImage extends _react.default.Component {
  constructor(props) {
    super(props); // default settings for browser without Intersection Observer available

    let isVisible = true;
    let imgLoaded = false;
    let IOSupported = false;
    let fadeIn = props.fadeIn; // If this image has already been loaded before then we can assume it's
    // already in the browser cache so it's cheap to just show directly.
    // TODO: useState in imageCache or suchlike!

    const seenBefore = (0, _ImageUtils.inImageCache)(props); // browser with Intersection Observer available

    if (!seenBefore && typeof window !== `undefined` && window.IntersectionObserver) {
      isVisible = false;
      IOSupported = true;
    } // Never render image during SSR


    if (typeof window === `undefined`) {
      isVisible = false;
    } // Force render for critical images


    if (props.critical) {
      isVisible = true;
      IOSupported = false;
    }

    const hasNoScript = !(this.props.critical && !this.props.fadeIn);
    this.state = {
      isVisible,
      imgLoaded,
      IOSupported,
      fadeIn,
      hasNoScript,
      seenBefore
    };
    this.bgImage = ``; // Get background(-*) styles from CSS (e.g. Styled Components).

    this.backgroundStyles = (0, _BackgroundUtils.default)(this.props.className);
    this.handleImageLoaded = this.handleImageLoaded.bind(this);
    this.handleRef = this.handleRef.bind(this); // "Fake" a reference to an Image loaded via picture element in background.

    this.imageRef = (0, _ImageUtils.createPictureRef)(this.props, this.handleImageLoaded); //createImageToLoad(this.props)
    // console.log(createPictureRef(this.props))
  }

  componentDidMount() {
    if (this.state.isVisible && typeof this.props.onStartLoad === `function`) {
      this.props.onStartLoad({
        wasCached: (0, _ImageUtils.inImageCache)(this.props)
      });
    }

    if (this.props.critical) {
      const img = this.imageRef;

      if (img && img.complete) {
        this.handleImageLoaded();
      }
    }
  }

  handleRef(ref) {
    if (this.state.IOSupported && ref) {
      (0, _IntersectionObserverUtils.listenToIntersections)(ref, () => {
        const imageInCache = (0, _ImageUtils.inImageCache)(this.props);

        if (!this.state.isVisible && typeof this.props.onStartLoad === `function`) {
          this.props.onStartLoad({
            wasCached: imageInCache
          });
        }

        this.setState({
          isVisible: true,
          imgLoaded: imageInCache
        });
      });
    }
  }

  handleImageLoaded() {
    (0, _ImageUtils.activateCacheForImage)(this.props);
    this.setState({
      imgLoaded: true
    });

    if (this.state.seenBefore) {
      console.log(`seen`);
      this.setState({
        fadeIn: false
      });
    }

    if (this.props.onLoad) {
      this.props.onLoad();
    }
  }

  render() {
    const _fixOpacity = (0, _StyleUtils.fixOpacity)((0, _HelperUtils.convertProps)(this.props)),
          title = _fixOpacity.title,
          alt = _fixOpacity.alt,
          className = _fixOpacity.className,
          _fixOpacity$style = _fixOpacity.style,
          style = _fixOpacity$style === void 0 ? {} : _fixOpacity$style,
          fluid = _fixOpacity.fluid,
          fixed = _fixOpacity.fixed,
          backgroundColor = _fixOpacity.backgroundColor,
          Tag = _fixOpacity.Tag,
          _fixOpacity$classId = _fixOpacity.classId,
          classId = _fixOpacity$classId === void 0 ? Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 7) : _fixOpacity$classId,
          children = _fixOpacity.children;

    const bgColor = typeof backgroundColor === `boolean` ? `lightgray` : typeof backgroundColor !== `undefined` ? backgroundColor : ``;
    const backgroundSize = this.backgroundStyles.hasOwnProperty(`backgroundSize`) ? this.backgroundStyles.backgroundSize : `cover`;
    const backgroundRepeat = `background-repeat: ${this.backgroundStyles.hasOwnProperty(`backgroundRepeat`) ? this.backgroundStyles.backgroundRepeat : `no-repeat`};`;
    const transitionDelay = this.state.imgLoaded ? `0.5s` : `0.25s`;

    if (fluid) {
      const image = fluid; // Set the backgroundImage according to images available.

      let bgImage = this.bgImage,
          nextImage = ``;
      if (image.tracedSVG) nextImage = `"${image.tracedSVG}"`;
      if (image.base64 && !image.tracedSVG) nextImage = image.base64;
      if (this.state.isVisible) nextImage = this.imageRef.currentSrc || image.src;
      const noBase64 = !image.base64; // Switch bgImage & nextImage and opacity accordingly.

      bgImage = bgImage === `` ? nextImage : this.bgImage;
      const afterOpacity = nextImage !== bgImage || this.state.fadeIn === false ? 1 : 0;
      this.bgImage = bgImage;
      const pseudoStyles = {
        classId,
        backgroundSize,
        backgroundRepeat,
        transitionDelay,
        bgImage,
        nextImage,
        afterOpacity,
        bgColor,
        noBase64 // console.log(createPseudoStyles(pseudoStyles))
        // console.log(backgroundColor, bgColor, `${bgColor && `background-color: ${bgColor};`}`)

      };
      return _react.default.createElement(Tag, {
        className: `${className ? className : ``} gatsby-background-image-${classId} gatsby-image-wrapper`,
        style: Object.assign({
          position: `relative`,
          overflow: `hidden`,
          opacity: .99
        }, style, this.backgroundStyles),
        ref: this.handleRef,
        key: `fluid-${JSON.stringify(image.srcSet)}`
      }, _react.default.createElement("style", {
        dangerouslySetInnerHTML: {
          __html: (0, _StyleUtils.createPseudoStyles)(pseudoStyles)
        }
      }), this.state.hasNoScript && _react.default.createElement("noscript", {
        dangerouslySetInnerHTML: {
          __html: (0, _ImageUtils.noscriptImg)(Object.assign({
            alt,
            title
          }, image))
        }
      }), children);
    }

    if (fixed) {
      const image = fixed;
      const divStyle = Object.assign({
        position: `relative`,
        overflow: `hidden`,
        display: `inline-block`,
        width: image.width,
        height: image.height,
        opacity: .99
      }, style);

      if (style.display === `inherit`) {
        delete divStyle.display;
      } // Set the backgroundImage according to images available.


      let bgImage = this.bgImage,
          nextImage = null;
      if (image.tracedSVG) nextImage = `"${image.tracedSVG}"`;
      if (image.base64 && !image.tracedSVG) nextImage = image.base64;
      if (this.state.isVisible) nextImage = this.imageRef.currentSrc || image.src;
      const noBase64 = !!image.base64; // Switch bgImage & nextImage and opacity accordingly.

      bgImage = bgImage === `` ? nextImage : this.bgImage;
      const afterOpacity = nextImage !== bgImage || this.state.fadeIn === false ? 1 : 0;
      this.bgImage = bgImage;
      const pseudoStyles = {
        classId,
        backgroundSize,
        backgroundRepeat,
        transitionDelay,
        bgImage,
        nextImage,
        afterOpacity,
        bgColor,
        noBase64
      };
      return _react.default.createElement(Tag, {
        className: `${className ? className : ``} gatsby-background-image-${classId} gatsby-image-wrapper`,
        style: Object.assign({}, divStyle, this.backgroundStyles),
        ref: this.handleRef,
        key: `fixed-${JSON.stringify(image.srcSet)}`
      }, _react.default.createElement("style", {
        dangerouslySetInnerHTML: {
          __html: (0, _StyleUtils.createPseudoStyles)(pseudoStyles)
        }
      }), this.state.hasNoScript && _react.default.createElement("noscript", {
        dangerouslySetInnerHTML: {
          __html: (0, _ImageUtils.noscriptImg)(Object.assign({
            alt,
            title,
            width: image.width,
            height: image.height
          }, image))
        }
      }), children);
    }

    return null;
  }

}

BackgroundImage.defaultProps = {
  critical: false,
  fadeIn: true,
  alt: ``,
  Tag: `div`
};

const fixedObject = _propTypes.default.shape({
  width: _propTypes.default.number.isRequired,
  height: _propTypes.default.number.isRequired,
  src: _propTypes.default.string.isRequired,
  srcSet: _propTypes.default.string.isRequired,
  base64: _propTypes.default.string,
  tracedSVG: _propTypes.default.string,
  srcWebp: _propTypes.default.string,
  srcSetWebp: _propTypes.default.string
});

const fluidObject = _propTypes.default.shape({
  aspectRatio: _propTypes.default.number.isRequired,
  src: _propTypes.default.string.isRequired,
  srcSet: _propTypes.default.string.isRequired,
  sizes: _propTypes.default.string.isRequired,
  base64: _propTypes.default.string,
  tracedSVG: _propTypes.default.string,
  srcWebp: _propTypes.default.string,
  srcSetWebp: _propTypes.default.string
});

BackgroundImage.propTypes = {
  resolutions: fixedObject,
  sizes: fluidObject,
  fixed: fixedObject,
  fluid: fluidObject,
  fadeIn: _propTypes.default.bool,
  title: _propTypes.default.string,
  alt: _propTypes.default.string,
  className: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.object]),
  // Support Glamor's css prop.
  critical: _propTypes.default.bool,
  style: _propTypes.default.object,
  imgStyle: _propTypes.default.object,
  placeholderStyle: _propTypes.default.object,
  placeholderClassName: _propTypes.default.string,
  backgroundColor: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.bool]),
  onLoad: _propTypes.default.func,
  onError: _propTypes.default.func,
  onStartLoad: _propTypes.default.func,
  Tag: _propTypes.default.string,
  classId: _propTypes.default.string
};
var _default = BackgroundImage;
exports.default = _default;